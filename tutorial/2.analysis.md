- [Overview](#overview)
- [Spatial features of a `Mosaic`](#spatial-features-of-a-mosaic)
  - [Boundary effects](#boundary-effects)
  - [Visualization of points](#visualization-of-points)
  - [Neighborhoods in a `Mosaic`](#neighborhoods-in-a-mosaic)
  - [Nearest Neighbor distances](#nearest-neighbor-distances)
  - [Voronoi Domain areas](#voronoi-domain-areas)
  - [Regularity Index](#regularity-index)
- [Probability distribution of a feature](#probability-distribution-of-a-feature)
  - [Create a feature](#create-a-feature)
  - [Set probabilities in `Distribution`](#set-probabilities-in-distribution)
  - [Visualization of probabilities](#visualization-of-probabilities)
    - [View probabilities of features from `Mosiac`s](#view-probabilities-of-features-from-mosiacs)
    - [Compare features among `Mosiac`s](#compare-features-among-mosiacs)

# Overview

This part guides the feature analysis and visualization of mosaics. Codes here follow [the 1st part](1.import.md) of the tutorial, you should run previous codes first. 

For customizable visualization, it is necessary to import
the `matplotlib` library, as
```python
import matplotlib.pyplot as plt
```

# Spatial features of a `Mosaic`

In this section, we introduce how to analyze and visualize [spatial features](0.background.md#spatial-pattern-analysis) in a single mosaic. We use [the natural mosaic](1.import.md#loading-a-mosaic) to present usages and results.

## Boundary effects 

Due to [boundary effects](0.background.md#boundary-effects), the first step in feature analysis is to label boundary points in the mosaic, and later statistics will skip these points. The `Mosaic` class provides two methods to access indices of boundary or effective points separately, as,

```python
# a numpy.darray(dtype=int) contains indices of boundary points
boundary_indices = natural_mosaic.get_boundary_indices()

# a numpy.darray(dtype=int) contains indices of effective points
effective_indices = natural_mosaic.get_effective_indices()
```
Besides, you can randomly select points with a given number by the `get_random_indices` method, as

```python
# a numpy.darray(dtype=int) contains indices of random points
random_indices = natural_mosaic.get_random_indices(n=30) 
# If n >= the number of points, it will return all indices with a random order 
```

## Visualization of points

We draw the above points in the `natural_mosaic` as the example to introduce visualization methods in `Mosiac`. Next is how to draw effective points by using the `draw_points` method.

```python
natural_mosaic.draw_points(highlights=effective_indices, nonhighlight_alpha=0.5, ax_grid=5, draw_plane_grid=True, ax_scaled=True, point_args={"color": "k", "s": 20}, ax=None) 
```

<p align="center">
<img src="imgs/ana-points-effectives.png" width="230">
<figcaption align = "center">Draw effective points in the mosaic.</figcaption>
</p>

The `draw_points` method has several arguments for setting highlight points, the properties of the axes and points, as
- `highlights`: Indices of solid points, default is `None`, and the method will highlight effective points.
- `nonhighlight_alpha`: Alpha of parent points, default is `0.3`.
- `ax_grid`: The number of ax-ticks in a side, default is `1`.
- `draw_plane_grid`: Whether draw grids with ax-ticks, default is `False`.
- `ax_scaled`: If it is True, the unit of x and y sides are same. Otherwise, two sides have the same length without other commands with the axes. Please visit the manual of [matplotlib.pyplot.Axes]() for more information.
- `point_args`: Arguments that are delivered into the [matplotlib.pyplot.scatter]() method to control properties of points. In the above sentence, we set the color of points as `k` (black) and the size of points as `20`. **__NOTE__:** If it has `alpha`, the alpha of un-highlight points is the multiple of given `alpha` and `nonhighlight_alpha` to ensure highlight points are more solid than others.
- `ax`: Drawing with the specified [Matplotlib axes](). If not provided, the method will create new axes and show drawing results at the end.

The next example draws red points and highlights boundary points, as

```python
natural_mosaic.draw_points(highlights=boundary_indices, nonhighlight_alpha=0.2, ax_grid=5, draw_plane_grid=False, ax_scaled=True, point_args={"color": "r", "s": 40}) 
```

<p align="center">
<img src="imgs/ana-points-boundaries.png" width="230">
<figcaption align = "center">Draw boundary points in the mosaic.</figcaption>
</p>

With specific axes, you can draw with several subplots. For example, 

```python
# The 1st subplot highlights effective points
ax1 = plt.subplot(131)
natural_mosaic.draw_points(highlights=effective_indices, nonhighlight_alpha=0.2, ax_grid=5, draw_plane_grid=True, ax_scaled=True, point_args={"color": "r", "s": 20}, ax=ax1) 
ax1.set_title("Solid points are effective")

# The 2nd subplot hightlights boundary points
ax2 = plt.subplot(132)
natural_mosaic.draw_points(highlights=boundary_indices, nonhighlight_alpha=0.2, ax_grid=5, draw_plane_grid=True, ax_scaled=True, point_args={"color": "r", "s": 20}, ax=ax2)
ax2.set_title("Solid points are boundary")

# The 3rd subplot hightlights randomly selected points
ax3 = plt.subplot(133)
natural_mosaic.draw_points(highlights=random_indices, nonhighlight_alpha=0.2, ax_grid=5, draw_plane_grid=True, ax_scaled=True, point_args={"color": "r", "s": 20}, ax=ax3)
ax3.set_title("Random (N=30) Selection")

# Show drawing results
plt.show() 
```

<p align="center">
<img src="imgs/ana-points-compare.png" width="6000">
<figcaption align = "center">Draw points with subplots.</figcaption>
</p>

Other visualization methods in `Mosaic` and `Pattern` support the ax-specific approach. Furthermore, similar to the `point_args`, several arguments in these methods are delivered into visualization methods in `maplotlib`. We recommend to check the manual of [matplotlib]() for more information.

## Neighborhoods in a `Mosaic`

The 2nd step of feature analysis is the [triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation), whose edges that link neighbors split the plane into triangle areas. With a `Mosaic`, it is easy to view the results of Delaunay triangulation, as

```python
natural_mosaic.draw_neighbors(highlights=None, nonhighlight_alpha=0.3, ax_grid=1, draw_plane_grid=False, ax_scaled=True, point_args={"s": 5, "color": "r"}, edge_args={"lw": 0.5, "color": "gray"}, ax=None)
```
<p align="center">
<img src="imgs/ana-neighbors.png" width="230">
<figcaption align = "center">Pairs of neighborhoods in the mosiac.</figcaption>
</p>

The `draw_neighbors` method shares several arguments with  [draw_points](2.analysis.md#visualization-of-points). Besides, it has an `edge_args` argument which decides the properties of edges in drawing and is delivered into [matplotlib.plot]() method.

Furthermore, there is a `find_neighbors` method to get neighbors of a given index, as

```python
guy = 16 # We try to find the neighbors of this guy.
# get a list of indices of neighbors. 
neighbors = natural_mosaic.find_neighbors(p_index=guy, effective_only=False)
```
where `p_index` is the index of the point and the method will discard boundary points in return if `effective_only=True`. By specific the `highlights` argument, we can show the index=16 cell and its neighbors, as

```python
# draw the index=16 cell
ax1 = plt.subplot(121)
natural_mosaic.draw_neighbors(highlights=[guy], nonhighlight_alpha=0.2, ax_grid=5, draw_plane_grid=False, ax_scaled=True, point_args={"color": "red", "s": 30}, edge_args={"lw": 0.5, "color": "gray"}, ax=ax1) 
ax1.set_title("The lucky guy")

# draw its neighbors
ax2 = plt.subplot(122)
natural_mosaic.draw_neighbors(highlights=neighbors, nonhighlight_alpha=0.2, ax_grid=5, draw_plane_grid=False, ax_scaled=True, point_args={"color": "red", "s": 30}, edge_args={"lw": 0.5, "color": "gray"}, ax=ax2)
ax2.set_title("Neighbors of the guy")
plt.show() 
```

<p align="center">
<img src="imgs/ana-neighbors-highlight.png" width="460">
<figcaption align = "center">A cell and its neighbors.</figcaption>
</p>

## Nearest Neighbor distances

The nearest neighbor (NN) and its distance to a point is an important feature. You can use `find_nearest_neighbor` to get the NN and its neighbor, as

```python
# NN distance and the NN neighbor of a point
nn_neighbor, nn_distance = natural_mosaic.find_nearest_neighbor(guy)
# nn_neighbor is the index of the NN neighbor.
# nn_distance is the distance from the point to its NN.
```

You can use `get_nns` to get NN distances from multiple points, as

```python
# NN distances of effective points
effective_nns = natural_mosaic.get_nns(indices=effective_indices, effective_filter=True)

# NN distances of all points
all_nns = natural_mosaic.get_nns(indices=None, effective_filter=False)
```
Arguments in `get_nns` methods are
- `indices` specific indices of query, default is `None` and return NN of all points,
- `effective_filter` Return only NNs of effective points.

The `Mosaic` has a `draw_nn_graph` method to show NN relationships as arcs from points to their NN neighbors.

```python
natural_mosaic.draw_nn_graph(highlights=None, nonhighlight_alpha=0.3, ax_grid=5, draw_plane_grid=False, ax_scaled=True, point_args={"s": 20, "color": "r"}, network_args={"edge_color": "k", "with_labels": False}, ax=None)
```
<p align="center">
<img src="imgs/ana-nns.png" width="230">
<figcaption align = "center">Effective points and their NN neighbors.</figcaption>
</p>

The `draw_nn_graph` method share most common arguments with  [draw_points](2.analysis.md#visualization-of-points), except
- `highlights`: Only draw NN graphs with given indices, default is `None` (= effective points).
- `network_args`: Arguments are delivered into [networkx.draw_networkx]() method to control the properties of the NN graph. **__NOTE__**: Arguments with points here have no effect.

## Voronoi Domain areas

Similarly, there are methods to access areas of Voronoi domains of points.

```python
# VD areas of effective points
effective_vds = natural_mosaic.get_vorareas(indices=None, effective_filter=True)

# VD areas of all points
all_vds = natural_mosaic.get_vorareas(indices=None, effective_filter=False)
```
You can use the `draw_vds` method to show Vornoi domains of a mosaic, as

```python
natural_mosaic.draw_vds(highlights=None, nonhighlight_alpha=0.3, ax_grid=5, ax_scaled=True, plane_args={"facecolor": "gray", "alpha": 0.2}, voronoi_args={"show_points": False, "line_width": 0.5}, point_args={"s": 20, "color": "r"}, ax=None)
```
<p align="center">
<img src="imgs/ana-vds.png" width="230">
<figcaption align = "center">Voronoid domains in the mosiac.</figcaption>
</p>

The `draw_vds` method share most common arguments with  [draw_points](2.analysis.md#visualization-of-points), except
- `plane_args`: Arguments are delivered into [matplotlib.PatchCollection]() method to control properties of the plane.
- `voronoi_args`: Arguments are delivered into [scipy.spatial.voronoi_plot_2d]() method to control properties of VDs. 

## Regularity Index

Based on the values of NN distances and VD areas, you can get [regularity indices](0.background.md#regularity-index) of the mosaic, as

```python
# Nearest Neighbor Regularity Index
natural_mosaic.NNRI() # 4.966138094971688

# Voronoi Domain Regularity Index
natural_mosaic.VDRI() # 5.790713936276296
```

**__NOTE__**: `NNRI` and `VDRI` only use values of effective points to calculate RI.

# Probability distribution of a feature

```python
from OPIPP import Distribution
```

## Create a feature

```python
# Distribution of NN distances
nn_distribution = Distribution(method="get_nns", min_value=0, max_value=50, n_bin=20)

# same as `natural_mosaic.get_nns()`
features = nn_distribution.extract_mosaic(natural_mosaic)

# or extract features from a list of mosaics
features = nn_distribution.extract_mosaics([natural_mosaic, simulated_mosaic])
```

```python
# a callable method in defination
vd_distribution = Distribution(method=lambda mosaic: mosaic.get_vorareas(), min_value=0,max_value=4000, n_bin=20)
# same as
vd_distribution = Distribution(method="get_vorareas", min_value=0,max_value=4000, n_bin=20)
```

```python
pattern.set_feature("NN", nn_distribution)
pattern.set_feature("VD", vd_distribution)
```

## Set probabilities in `Distribution`


```python
mosaics = [natural_mosaic]
values = nn_distribution.extract_mosaics(mosaics)
hist = nn_distribution.get_hist(values)
nn_distribution.set_target(hist)
```

```python
# estimate probability with pattern.natural_mosaics
probs = pattern.set_feature_target(feature_label="NN")
```

```python
nn_distribution.view()
```

<p align="center">
<img src="imgs/ana-nn-single.png" width="230">
<figcaption align = "center">Histogram of NN distances in the mosaic.</figcaption>
</p>

```python
target = np.array([0.        , 0.        , 0.        , 0.0016756 , 0.00670241,
       0.02010724, 0.04356568, 0.08713137, 0.11394102, 0.17258713,
       0.16253351, 0.16253351, 0.1152815 , 0.06635389, 0.0325067 ,
       0.01005362, 0.00268097, 0.00134048, 0.00067024, 0.00033512, 0])
nn_distribution.set_target(target)
```

```python
ax1 = plt.subplot(121)
probs = pattern.set_feature_target(feature_label="NN")
nn_distribution.view(ax=ax1, alpha=0.4, color='gray')
ax1.set_title("Distribution from a mosaic")

ax2 = plt.subplot(122)
nn_distribution.set_target(target)
nn_distribution.view(ax=ax2, alpha=0.7, color='k')
ax2.set_title("Distribution from a dataset")

plt.show()
```
<p align="center">
<img src="imgs/ana-nn-dataset.png" width="460">
<figcaption align = "center">Histogram of NN distances from multiple mosaics is more stable.</figcaption>
</p>

## Visualization of probabilities

```python
vd_distribution.set_target(np.array([0.        , 0.        , 0.00608906, 0.0617784 , 0.17183275,
       0.27966751, 0.27633813, 0.13262011, 0.05992875, 0.0117453 ,
       0.        , 0.        , 0.        , 0.        , 0.        ,
       0.        , 0.        , 0.        , 0.        , 0.        , 0.        ]))

print(pattern)
```

```
Spatial pattern of Mouse Horizontal Cell, 
- Density: Unknown,
- Natural mosaics: 1 case(s),
- Simulated mosaics: total 30 case(s)
   0 case(s) in tag 'default',
   10 case(s) in tag 'O-PIPP',
   20 case(s) in tag 'PIPP',
- Features: 2
         Label  | Has target probabilities
         NN     | True
         VD     | True .
```

### View probabilities of features from `Mosiac`s

```python
pattern.draw_feature_hist("NN", natural_color="skyblue", target_color="gray", simulated_color="red", simulated_tag="O-PIPP")
```

<p align="center">
<img src="imgs/ana-nn-all.png" width="230">
<figcaption align = "center">Natural vs. dataset vs. simulated historgrams.</figcaption>
</p>

### Compare features among `Mosiac`s

```python
ax1 = plt.subplot(121)
pattern.draw_feature_hist("NN", natural_color=None, target_color="gray", simulated_color="red", simulated_tag="O-PIPP", ax=ax1)

ax2 = plt.subplot(122)
pattern.draw_feature_hist("NN", natural_color=None, target_color="gray", simulated_color="red", simulated_tag="PIPP", ax=ax2)

plt.show()
```

<p align="center">
<img src="imgs/ana-nn-compare.png" width="230">
<figcaption align = "center">Compare features in two simulated groups with histograms.</figcaption>
</p>


```python
pattern.draw_values_boxes(feature_label="NN", draw_natural=True, simulated_tags=["O-PIPP", "PIPP"])
```
<p align="center">
<img src="imgs/ana-nn-box.png" width="230">
<figcaption align = "center">Compare features in two simulated groups with boxplot.</figcaption>
</p>


```python
nnri_distribution = Distribution("NNRI", 10)
pattern.set_feature("NNRI", nnri_distribution)
vdri_distribution = Distribution("VDRI", 10)
pattern.set_feature("VDRI", vdri_distribution)
pattern.draw_values_bars(draw_loss=False, feature_colors={"NNRI": "r", "VDRI": "b"}, draw_natural=False, simulated_tags=["O-PIPP", "PIPP"], width=0.3)
```

<p align="center">
<img src="imgs/ana-ri-all.png" width="230">
<figcaption align = "center">Compare mean value of features in two simulated groups.</figcaption>
</p>
