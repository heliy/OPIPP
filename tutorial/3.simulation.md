Table of Contents
- [Overview](#overview)
- [Preparation](#preparation)
  - [Set cell density](#set-cell-density)
  - [Interaction function](#interaction-function)
- [Simulation](#simulation)
  - [Creating a random mosaic](#creating-a-random-mosaic)
  - [Check usable features](#check-usable-features)
  - [Optimization Target](#optimization-target)
  - [Optimization Routine](#optimization-routine)
  - [Annealing schedule](#annealing-schedule)
- [Extention](#extention)
  - [Spatial features](#spatial-features)
  - [Optimization Entropy](#optimization-entropy)
  - [Cooling Schedule](#cooling-schedule)

# Overview

Before generating a new artificial mosaic, we show information on `pattern` through the previous tutorial, as

```python
print(pattern)
```
The outputs are

```texture
Spatial pattern of Mouse Horizontal Cell, 
- Density: Unknown,
- Natural mosaics: 1 case(s),
- Simulated mosaics: total 30 case(s)
   0 case(s) in tag 'default',
   10 case(s) in tag 'O-PIPP',
   20 case(s) in tag 'PIPP',
- Features: 2
         Label  | Has target probabilities
         NN     | True
         VD     | True
         NNRI   | False
         VDRI   | False .
```

# Preparation

The `Pattern` require more information on natural mosaics for simulation and optimization, including the density of cells and the interaction function between two cells.

## Set cell density

`Pattern` has an `estimate_density` to analyze cell density in natural mosaics, as

```python
density = pattern.estimate_density()
# 87/90000.
```

The cell density tells the `pattern` of the number of cells in a mosaic, which is essential in mosaic simulation. We use the `set_density` method to add the density into the `pattern`, as

```python
pattern.set_density(density=density)

pattern.set_density(87/90000.) # direct input the density
print(pattern)
```
Therefore, the "Density" in the outputs has its value.

```
Spatial pattern of Mouse Horizontal Cell, 
- Density: 0.0009667 (cells/unit^2),
- Natural mosaics: 1 case(s),
- Simulated mosaics: total 30 case(s)
   0 case(s) in tag 'default',
   10 case(s) in tag 'O-PIPP',
   20 case(s) in tag 'PIPP',
- Features: 4
         Label  | Has target probabilities
         NN     | True
         VD     | True
         NNRI   | False
         VDRI   | False .
```

## Interaction function

The simulation of mosaic requires an **interaction function**, denoted as `h(u)` to estimate the probability of a distance between any two points in a spatial pattern. With theoretical works from the field of [spatial point pattern analysis](), the formation of the interaction function is flexible. It only has one constraint as `0 <= h(u) <=1` for `u >= 0`.

Here we recommend a well-known formation of `h(u)` for retinal mosaics, as
$$h(u)= \begin{cases} 0,\quad u\leq θ\\ 1-exp(-((u-θ)/φ)^{α}), \quad u>θ \end{cases},$$

where θ, φ, α are parameters estimated by the Poisson point process. Besides, we recommend a [`R` script](estimate_inter_ps.md) to get parameters in $h(u)$. 


With estimated parameters, we can get the callable function through the `get_interaction_func` method, as

```python
parameters = [7.5, 32.1206741, 2.64876305] # [θ, φ, α]
h_func = pattern.get_interaction_func(parameters) 
```

# Simulation

The routine of mosaic simulation is the **insert-update-optimize** framework. It creates a random pattern and updates a cell's position following the probability yield by the interaction function. After an update iteration with several cells, it calculates the performance of the simulated mosaic and uses an adaptive simulated annealing algorithm to ensure the road of the mosaic is towards to given features and their probability distributions. 

In this section, we use NN and VD features as the optimization target and show how to generate a new mosaic in `OPIPP`.

## Creating a random mosaic

The 1st step of the simulation is to create a random mosaic through the `new_mosaic` method, as

```python
mosaic = pattern.new_mosaic(scope=scope)
mosaic.draw_points()
```
<p align="center">
<img src="imgs/sim-random.png" width="230">
<figcaption align = "center">Random points at initialization.</figcaption>
</p>

You need input a `Scope` to tell the `pattern` how large is the plane.

## Check usable features

Next, you need to decide on features in optimization. A feature that is usable in optimization should have the probability distribution through `Distribution.set_target` or `Pattern.set_feature_target`. The `pattern` has four features and only the "NN" and the "VD" feature have target probabilities. You can use the `get_usable_features` to check all usable features in the `pattern`.

```python
usable_features = pattern.get_usable_features()
# It is ["NN", "VD"]
```

## Optimization Target

Once we have decided on features for optimization, we can evaluate the `Entropy` of a mosaic by calculating its KL divergence to target features, as

$$Entropy(Simulated)=\sum_{feature}KL(Feature(Simulated), Target_{feature})),$$

where $feature$ and $Feature$ denote a spatial feature and the related method that calculates the probabilistic distribution of features in a given mosaic. The $Entropy$ is the sum of KL divergence between distributions from the simulated mosaic and the $target$.

In `OPIPP`, you can use the `evaluate` method to calculate the entropy of a mosaic or a series of mosaics. For example, we calculate the entropy of the random mosaic as

```python
# input the mosaic and target features
print(pattern.evaluate([mosaic], features=usable_features))
# return is 5.233049009275092
# If the input is a list of mosaics, it will calculate distributions of these mosaics and yield a single value.
```

## Optimization Routine

The `simulate` method in `pattern` play the role of update and optimization.

```python
from OPIPP import AdaptiveSchedule
mosaic, losses = pattern.simulate(mosaic=mosaic, interaction_func=h_func, features=None, schedule=AdaptiveSchedule(), max_step=None, update_ratop=None, save_prefix="examples/simulated/HC/Sample", save_step=500, verbose=True)

# the entropy of the final mosaic
print(pattern.evaluate([mosaic], features=usable_features))
# 0.0288679366606423

mosaic.draw_points()
```

<p align="center">
<img src="imgs/sim-optimized.png" width="230">
<figcaption align = "center">Simulated mosaic after optimization.</figcaption>
</p>

Arguments in `simulate` are
- `mosaic`: The input mosaic.
- `interaction_func`: The interaction function, default=`None`. If it is `None`, the method will use `h(u)=1.0` to accept all updates in cells.
- `features`: The target features for optimization, default=`None`. If it is `None`, the method will use all usable features.
- `schedule`: Annealing schedule for simulated annealing algorithm in optimization, default=`AdaptiveSchedule()`. [Here](3.simulation.md#annealing-schedule) is a more complete description. If it is `None`, the method will accept all updates after an iteration.
- `max_step`: The maximum number of iteration steps, default=`None`. If it is `None` and `schedule` is `None` as well, the method will use `20` as the default value. Otherwise, the method will loop until the schedule is terminated or reaches the maximum step of iterations.
- `update_ratio`: The ratio of cells in an iteration step, default=`None`. If it is `None` and `schedule` is `None` as well, the method will use `1.0` as the default value. If it is `None` but `schedule` is not `None`, the method will use `0.01` in an iteration.
- `save_prefix`: Save the mosaics into local files if given. The output file is `save-prefix_index-of-iteraction.points`.
- `save_step`: The step of saving into local files, default=`1`.
- `verbose`: Whether print the change of entropy during optimization, default=`True`.

`loss` is the trace of entropies alongside the optimization. You can plot it as

```python
plt.plot(losses)
plt.show()
```

<p align="center">
<img src="imgs/sim-losses.png" width="230">
<figcaption align = "center">The trace of Entropy during optimization</figcaption>
</p>

Besides, we recommend using `MPI` to simulate multiple mosaics in parallel. [Here](parallel_processing.md) is an example. 

## Annealing schedule

The `OPIPP` use the [simulated annealing algorithm](https://en.wikipedia.org/wiki/Simulated_annealing) to optimize the performance of the simulated mosaic. The algorithm uses a `temperature` to estimate the probability of accepting worse cases and requires an annealing schedule to control the process of iteration. We recommend using the `AdaptiveSchedule` in practice. The creation of an `AdaptiveSchedule` object is

```python
from OPIPP import AdaptiveSchedule
schedule = AdaptiveSchedule(alpha=0.95, init_t=0.5, min_t=1e-4)
```

Arguments are
- `alpha`: The descent parameter in the adaptive schedule, defalut=`0.95`.
- `init_t`: The value of temperature at initialization, default=`0.5`.
- `min_t`: The value of temperature for termination, default=``. 

Please check the [adaptive simulated annealing algorithm](https://optimization-online.org/wp-content/uploads/2001/03/291.pdf) for more information.

# Extention

## Spatial features

## Optimization Entropy

## Cooling Schedule
